#!/usr/bin/python
# -*- coding: utf-8 -*-

import os
import sys
import multiprocessing

import piksemel

import pisi
import pisi.dependency as dependency
import pisi.pxml.xmlfile as xmlfile
import pisi.pxml.autoxml as autoxml
import pisi.component as component
import pisi.specfile as specfile
import pisi.metadata as metadata
import pisi.group as group
from pisi.graph import CycleException

from buildfarm.config import configuration as conf
from buildfarm.queuemanager import QueueManager as qm
class Error(pisi.Error):
    pass

class Index(xmlfile.XmlFile):
    __metaclass__ = autoxml.autoxml

    tag = "PISI"

    t_Distribution = [ component.Distribution, autoxml.optional ]
    t_Specs = [ [specfile.SpecFile], autoxml.optional, "SpecFile"]
    t_Packages = [ [metadata.Package], autoxml.optional, "Package"]
    #t_Metadatas = [ [metadata.MetaData], autoxml.optional, "MetaData"]
    t_Components = [ [component.Component], autoxml.optional, "Component"]
    t_Groups = [ [group.Group], autoxml.optional, "Group"]

    def index(self, specs):
        print "Indexing ..."
        pool = multiprocessing.Pool()

        if specs:
            try:
                self.specs = pool.map(add_spec, specs)
            except KeyboardInterrupt:
                pool.terminate()
                pool.join()
                raise Exception

        pool.close()
        pool.join()

def add_spec(path):
    print "Adding %s" % path
    try:
        builder = pisi.operations.build.Builder(path)
        builder.fetch_component()
        sf = builder.spec
        sf.source.sourceURI = os.path.realpath(path)
        return sf

    except KeyboardInterrupt:
        raise Exception

#------- http://svn.pardus.org.tr/uludag/trunk/scripts/circledep-finder used for this part of code 
class SourceDB:
    def __init__(self, index):

        self.__source_nodes = {}
        self.__pkgstosrc = {}

        doc = piksemel.parseString(index)
        self.__source_nodes, self.__pkgstosrc = self.__generate_sources(doc)

    def __generate_sources(self, doc):
        sources = {}
        pkgstosrc = {}

        for spec in doc.tags("SpecFile"):
            src_name = spec.getTag("Source").getTagData("Name")
            sources[src_name] = spec.toString()
            for package in spec.tags("Package"):
                pkgstosrc[package.getTagData("Name")] = src_name

        return sources, pkgstosrc

    def has_spec(self, name):
        return self.__source_nodes.has_key(name)

    def get_spec(self, name):
        src = self.__source_nodes[name]
        spec = pisi.specfile.SpecFile()
        spec.parse(src)
        return spec

    def list_specs(self):
        return self.__source_nodes.keys()

    def pkgtosrc(self, name):
        return self.__pkgstosrc[name]

def find_circle(sourcedb, A):

    G_f = pisi.graph.Digraph()

    def get_spec(name):
        if sourcedb.has_spec(name):
            return sourcedb.get_spec(name)
        else:
            raise Exception('Cannot find source package: %s' % name)

    def get_src(name):
        return get_spec(name).source

    def add_src(src):
        if not str(src.name) in G_f.vertices():
            G_f.add_vertex(str(src.name), (src.version, src.release))

    def pkgtosrc(pkg):
        try:
            tmp = sourcedb.pkgtosrc(pkg)
        except KeyError, e:
            # this is a bad hack but after we hit a problem we need to continue
            tmp = "e3"
            print "---> borks in ", e

        return tmp

    B = A

    install_list = set()

    while len(B) > 0:
        Bp = set()
        for x in B:
            sf = get_spec(x)
            src = sf.source
            add_src(src)

            # add dependencies

            def process_dep(dep):
                srcdep = pkgtosrc(dep.package)
                if not srcdep in G_f.vertices():
                    Bp.add(srcdep)
                    add_src(get_src(srcdep))
                if not src.name == srcdep: # firefox - firefox-devel thing
                    G_f.add_edge(src.name, srcdep)

            for builddep in src.buildDependencies:
                process_dep(builddep)

            for pkg in sf.packages:
                for rtdep in pkg.packageDependencies:
                    process_dep(rtdep)
        B = Bp

        try:
            order_build = G_f.topological_sort()
            order_build.reverse()
        except CycleException, cycle:
            return str(cycle)

    return ""

def processPackage(pkg, sourcesLength, counter):
    global sourcedb

    sys.stdout.write("\r(%04d/%d) Calculating build dep of %s                       " % (counter, sourcesLength, pkg))
    sys.stdout.flush()

    return find_circle(sourcedb, [pkg])

def updateStatus(circleResult):
    global cycles
    cycles.add(circleResult)
#------ end

class QueueManager(qm):
    def __init__(self):
        self.workQueue = []
        self.waitQueue = []

        self.workQueueFileName = "workqueue"
        self.waitQueueFileName = "waitqueue"

        self.__deserialize(self.workQueue, self.workQueueFileName)
        self.__deserialize(self.waitQueue, self.waitQueueFileName)

        # Ignore empty lines
        self.workQueue = list(set([s for s in self.workQueue if s]))
        self.waitQueue = list(set([s for s in self.waitQueue if s]))

    def get_queue(self):
        return [pspec for pspec in set(self.waitQueue + self.workQueue)]

if __name__ == "__main__":
    
    queue_manager = QueueManager()
    queue = queue_manager.get_queue()

    if len(queue) == 0:
        logger.info("Work Queue is empty...")
        sys.exit(1)

    index = Index()
    index.distribution = None
    index.index(queue)
    
    indexfile = "%s/pisi-index.xml" % conf.workdir
    index.write(indexfile, sha1sum=False, compress=None, sign=None)
    print "Index file written to %s\n" % indexfile 

    rawIndex = open(indexfile, "r").read()
    sourcedb = SourceDB(rawIndex)
    sources = sourcedb.list_specs()

    sourcesLength = len(sources)
    counter = 0

    global cycles
    cycles = set()

    pool = multiprocessing.Pool()

    for pkg in sources:
        counter += 1
        pool.apply_async(processPackage, (pkg, sourcesLength, counter), callback=updateStatus)

    pool.close()
    pool.join()

    if len(cycles):
        print
        for cycle in cycles:
            print cycle
    else:
        print "No circular dep found"
